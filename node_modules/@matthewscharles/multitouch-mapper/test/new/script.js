class Touch {
  constructor() {
    this.listeners = ['touchstart', 'touchmove', 'touchend']
    this.listen();
    this.preventDefault = true;
    this.buffer = {};
    this.eventQueue = [];
    this.actions = {
      'rect': {
        start: (element, e, obj) => {
          console.log('ðŸŸ ðŸŸ ðŸŸ start', obj.id, obj.x, obj.y)
        },
        enter: (element, e, obj) => {
          console.log('ðŸŸ ðŸŸ ðŸŸ enter', obj.id, obj.x, obj.y)
        },
        move: (element, e, obj) => {
          if (obj.iterations == 0) {
            console.log('ðŸŸ ðŸŸ ðŸŸ move', obj.id, obj.x, obj.y)
          }
        },
        drag: (element, e, obj) => {
          console.log('drag', element, e)
        },
        leave: (element, e, obj) => {
          console.log('ðŸŸ ðŸŸ ðŸŸ leave', obj.id, obj.x, obj.y)
        },
        end: (element, e, obj) => {
          console.log('ðŸŸ ðŸŸ ðŸŸ end', obj.id, obj.x, obj.y)
        }
      }
    }
  }
}

Touch.prototype.listen = function() {
  this.listeners.forEach(x => {
    document.addEventListener(x, this)
  })
  return this;
}

Touch.prototype.getList = function(x, y) {
  return document.elementsFromPoint(x, y)
}

Touch.prototype.processElement = function(element, identifier, i, type, e, touch, elementId) {
  let identified = false;

  Object.entries(this.actions).forEach(([index, value], i) => {
    
    let match = false;
    if (typeof element == 'object') {
      match = element.matches(index);
      elementId = element.id;
    } else if (typeof element == 'string') {
      match = element == index;
      element = document.querySelector(`#${elementId}`)
    }

    if (match) {

      let assignment = this.buffer[identifier].elements;

      if (!Object.keys(assignment).includes(elementId)) {
        assignment[elementId] = {
          id: elementId,
          element: element,
          time: Date.now(),
          type: type == 'start' ? 'start' : 'enter',
          x: touch.clientX,
          y: touch.clientY,
          query: index,
          iterations: 0,
          origin:{
            x: touch.clientX,
            x: touch.clientY
          },
          distance:{
            x:0,
            y:0,
          },
          path:{
            x:[touch.clientX],
            y:[touch.clientY]
          },
          delta:{
            x:0,
            y:0
          }
        }

      } else if (type == 'move') {

        assignment[elementId].type = 'move';
        assignment[elementId].query = index;
        assignment[elementId].delta.x = touch.clientX - assignment[elementId].x;
        assignment[elementId].delta.y = touch.clientY - assignment[elementId].y;
        assignment[elementId].path.x.push(touch.clientX);
        assignment[elementId].path.y.push(touch.clientY);
        assignment[elementId].x = touch.clientX;
        assignment[elementId].y = touch.clientY;
        assignment[elementId].distance.x = touch.clientX -  assignment[elementId].origin.x;
        console.log('distance.x',assignment[elementId].distance.x)
        assignment[elementId].distance.y = touch.clientY -  assignment[elementId].origin.y;
        assignment[elementId].iterations += 1;

      } else if (type == 'end') {

        assignment[elementId].type = 'end';

      } else if (type == 'leave') {

        assignment[elementId].type = 'leave';

      } else {
        // didn't match...
      }

      this.eventQueue.push([index, assignment[elementId].type, element, e, assignment[elementId]])
      identified = true;

    }
  })
  return identified;
}

Touch.prototype.handleEvent = function(e) {

  if (e.type == 'touchstart') {

    Array.from(e.changedTouches).forEach(x => {
      
      this.buffer[x.identifier] = {
        elements: {},
        history: {}
      }

      let newTouch = this.getList(x.clientX, x.clientY);

      newTouch.forEach((item, i) => {
        this.processElement(item, x.identifier, i, 'start', e, x)
      });

    })

  } else if (e.type == 'touchmove') {

    Array.from(e.touches).forEach(x => {
      let identifiedElements = []
      let newTouch = this.getList(x.clientX, x.clientY);

      // todo: if mouse and mouse is down, drag
      // todo: use time threshold / timeout to set a touched item as dragged
      newTouch.forEach((item, i) => {
        if (this.processElement(item, x.identifier, i, 'move', e, x)) identifiedElements.push(item.id)
      })

      Object.entries(this.buffer[x.identifier].elements).forEach(([item, contents], i) => {
        if (!identifiedElements.includes(item)) {
          this.buffer[x.identifier].history[item] = this.buffer[x.identifier].elements[item];
          this.processElement(contents.query, x.identifier, i, 'leave', e, x, item)
          delete this.buffer[x.identifier].elements[item];
        }
      })
     
    })


  } else if (e.type == 'touchend') {

    Array.from(e.changedTouches).forEach(x => {
      Object.entries(this.buffer[x.identifier].elements).forEach(([item, contents], i) => {
        this.processElement(contents.query, x.identifier, i, 'end', e, x, item)
      })

      delete this.buffer[x.identifier];

    })
  }
  this.eventQueue.forEach(([index, type, element, e, obj]) => {
    this.actions[index][type](element, e, obj);
  })

  this.eventQueue = []
  if(this.preventDefault) e.preventDefault();
}


let test = new Touch();


const processElement = function(element, identifier, i, type, e, touch, elementId) {
    let identified = false;
  
    Object.entries(this.actions).forEach(([index, value], i) => {
      
      let match = false;
      if (typeof element == 'object') {
        match = element.matches(index);
        elementId = element.id;
      } else if (typeof element == 'string') {
        match = element == index;
        element = document.querySelector(`#${elementId}`)
       
      }
  
      if (match) {
       
        let assignment = this.buffer[identifier].elements;
        // maintain original rect for the purposes of debouncing
        const rect = element.getBoundingClientRect();

        if (!Object.keys(assignment).includes(elementId)) {
          
          assignment[elementId] = {
            id: elementId,
            element: element,
            time: Date.now(),
            type: type == 'start' ? 'start' : 'enter',
            x: touch.clientX,
            y: touch.clientY,
            query: index,
            iterations: 0,
            rect:{
              original: rect,
              current: rect
            },
            origin:{
              x: touch.clientX,
              y: touch.clientY
            },
            relative:{
              x:touch.clientX - rect.left,
              y:rect.bottom - touch.clientY,
              range: {
                x: rect.width,
                y: rect.height
              }
            },
            distance:{
              x:0,
              y:0
            },
            path:{
              x:[touch.clientX],
              y:[touch.clientY]
            },
            delta:{
              x:0,
              y:0
            }
          }
          // console.log(assignment[elementId]);

        } else if (type == 'move') {
  
          assignment[elementId].type = 'move';
          assignment[elementId].query = index;
          assignment[elementId].delta.x = touch.clientX - assignment[elementId].x;
          assignment[elementId].delta.y = touch.clientY - assignment[elementId].y;
          assignment[elementId].path.x.push(touch.clientX);
          assignment[elementId].path.y.push(touch.clientY);
          assignment[elementId].x = touch.clientX;
          assignment[elementId].y = touch.clientY;
          assignment[elementId].relative.x = touch.clientX - rect.left;
          assignment[elementId].relative.y = rect.bottom - touch.clientY;
          assignment[elementId].distance.x = touch.clientX -  assignment[elementId].origin.x;
          assignment[elementId].distance.y = touch.clientY -  assignment[elementId].origin.y;
          assignment[elementId].iterations += 1;
  
          // console.log(assignment[elementId].relative.x, assignment[elementId].relative.y);
  
        } else if (type == 'end') {
          
          
          assignment[elementId].type = 'end';
  
        } else if (type == 'leave') {
  
          assignment[elementId].type = 'leave';
  
        } else {
          // didn't match...
          
        }
  
        this.eventQueue.push([index, assignment[elementId].type, element, e, assignment[elementId]])
        identified = true;
  
      }
    })
    return identified;
  }
  
module.exports = processElement;
  
  
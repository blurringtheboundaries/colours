const emit = require('@matthewscharles/cm-toolbox').emit;


/**
 * Function to handle all new information from the listener
 * @param {object} e event from listener
 */

const handleEvent = function(e) {

    this.mono = false;
    window.currentPreventDefault = this.preventDefault;

    let event = e;
    if(e.type.includes('mouse')){
      if(e.type=='mousedown'){
        e = {
          type:'touchstart',
          changedTouches:[
            {
              identifier:'mouse',
              clientX:e.clientX,
              clientY:e.clientY,
              preventDefault:function(e){
                e.preventDefault()
              }.bind(e)
            }
          ]
        }
      } else if(e.type=='mousemove' && e.buttons>0){
        e = {
          type:'touchmove',
          touches:[
            {
              identifier:'mouse',
              clientX:e.clientX,
              clientY:e.clientY,
              preventDefault:function(e){
                e.preventDefault()
              }.bind(e)
            }
          ]
        }
       } else if(e.type=='mouseup'){
          e = {
            type:'touchend',
            changedTouches:[
              {
                identifier:'mouse',
                clientX:e.clientX,
                clientY:e.clientY,
                preventDefault:function(e){
                  e.preventDefault()
                }.bind(e)
              }
            ]
          }
        }
      }
    
    if (e.type == 'touchstart') {
      if(Object.keys(this.buffer).length==0) this.touchStartTime = Date.now();
      Array.from(e.changedTouches).forEach(x => {
        
        this.buffer[x.identifier] = {
          elements: {},
          history: {}
        }
  
        let newTouch = this.getListOfElements(x.clientX, x.clientY)
          .slice(0,this.depth);
        
        newTouch.forEach((item, i) => {
          this.processElement(item, x.identifier, i, 'start', e, x)
        });
        
      })
  
    } else if (e.type == 'touchmove') {
  
      Array.from(e.touches).forEach(x => {

        let identifiedElements = []
        let newTouch = this.getListOfElements(x.clientX, x.clientY)
          .slice(0,this.depth);
  

        // todo: if mouse and mouse is down, drag
        // todo: use time threshold / timeout to set a touched item as dragged

        newTouch.forEach((item, i) => {
          if (this.processElement(item, x.identifier, i, 'move', e, x)) identifiedElements.push(item.id)
        })

        // todo: incorporate mouseover
        
        if(Object.keys(this.buffer).length>0){
          
          Object.entries(this.buffer[x.identifier].elements).forEach(([item, contents], i) => {
            
            if (!identifiedElements.includes(item)) {
              this.buffer[x.identifier].history[item] = this.buffer[x.identifier].elements[item];
              this.processElement(contents.query, x.identifier, i, 'leave', e, x, item)
              delete this.buffer[x.identifier].elements[item];
            }

          })

        }

      })
  
  
    } else if (e.type == 'touchend') {
      
      Array.from(e.changedTouches).forEach(x => {
        Object.entries(this.buffer[x.identifier].elements).forEach(([item, contents], i) => {
          this.processElement(contents.query, x.identifier, i, 'end', e, x, item)
        })
  
        delete this.buffer[x.identifier];
  
      })
    }
    
    this.eventQueue.forEach(([index, type, element, e, obj]) => {
      if(typeof this.actions[index][type] == 'function') this.actions[index][type](element, e, obj);
      if(this.customEvent.enabled){
        emit(this.customEvent.name,obj);
      }
    })
  
    this.eventQueue = [];

    if(window.currentPreventDefault) {
      event.preventDefault();
    }

  }
  
module.exports = handleEvent;